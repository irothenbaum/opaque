{"version":3,"sources":["webpack://opaque/webpack/universalModuleDefinition","webpack://opaque/webpack/bootstrap","webpack://opaque/./game/main.js","webpack://opaque/webpack://twocylinder/webpack/universalModuleDefinition","webpack://opaque/webpack://twocylinder/webpack/bootstrap","webpack://opaque/webpack://twocylinder/src/engine/utilities.js","webpack://opaque/webpack://twocylinder/src/engine/root.js","webpack://opaque/webpack://twocylinder/src/engine/generic.js","webpack://opaque/webpack://twocylinder/src/engine/bounding/bounding.js","webpack://opaque/webpack://twocylinder/src/engine/bounding/bounding_point.js","webpack://opaque/webpack://twocylinder/src/engine/bounding/bounding_circle.js","webpack://opaque/webpack://twocylinder/src/engine/bounding/bounding_box.js","webpack://opaque/webpack://twocylinder/src/engine/vector.js","webpack://opaque/webpack://twocylinder/src/engine/appearance.js","webpack://opaque/webpack://twocylinder/src/engine/background.js","webpack://opaque/webpack://twocylinder/src/io/event.js","webpack://opaque/webpack://twocylinder/src/io/touch.js","webpack://opaque/webpack://twocylinder/src/sprites/joystick.js","webpack://opaque/webpack://twocylinder/src/build.js","webpack://opaque/webpack://twocylinder/src/engine/entity.js","webpack://opaque/webpack://twocylinder/src/engine/game.js","webpack://opaque/webpack://twocylinder/src/engine/particle.js","webpack://opaque/webpack://twocylinder/src/engine/particle_emitter.js","webpack://opaque/webpack://twocylinder/src/engine/view.js","webpack://opaque/webpack://twocylinder/src/engine/world.js","webpack://opaque/webpack://twocylinder/src/io/joystick.js","webpack://opaque/(webpack)/buildin/module.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","TC","require","OpaqueGame","Engine","Game","canvas","document","getElementById","menuBackground","Background","color","world","World","fps","width","height","background","view","View","resolution","bounding","getBounding","addView","this","setWorld","start","_typeof2","__WEBPACK_AMD_DEFINE_ARRAY__","undefined","__WEBPACK_AMD_DEFINE_RESULT__","__WEBPACK_AMD_DEFINE_FACTORY__","apply","Vector","Constants","TAU","Math","Functions","disjoinArray2FromArray1","array1","array2","onEachMatchCallback","j","length","__id","clone","obj","Geometry","boxCollidesBox","box1","box2","xOverlap","origin_x","yOverlap","origin_y","boxCollidesCircle","box","circle","point1","x","y","point2","point3","point4","line1","line2","line3","line4","boxCollidesPoint","point","circleCollidesCircle","circle1","circle2","distanceToPoint","radius","circleCollidesBox","circleCollidesLine","line","isSegment","circleCollidesPoint","lineIntersectsCircle","b","a","eDistAtoB","e","eDistCtoE","retVal","dt","f","g","parseInt","lineCollidesCircle","intersects","lineCollidesPoint","angleToPoint1","angleToPoint2","pointCollidesCircle","pointCollidesBox","pointCollidesPoint","pointCollidesLine","angleToPoint","inDegrees","radians","PI","pointToPoint","speed","direction","pointFromVector","vector","getSpeed","getRandomDirection","Root","_classCallCheck","Bounding","Generic","options","_this","_possibleConstructorReturn","_getPrototypeOf","setBounding","_bounding","collides","rotation","tuple","setCenter","_this2","_typeof","updateBounding","_toConsumableArray","BoundingBox","BoundingCircle","BoundingPoint","containingBox","getContainingRectangle","myBox","targetX","targetY","assign","__direction","__speed","dir","friction","currentDirection","getDirection","directionDiff","setDirection","Appearance","scale","entity","context","_color","getCanvas","containingRectangle","Event","evt","el","target","isNaN","offsetTop","_super","world_x","world_y","rect","getBoundingClientRect","device_x","left","device_y","top","timestamp","Date","now","TAP","DOUBLE","LONG","MOVE","UP","DOWN","linked_event","velocity","eventType","type","Touch","__view","double","tap","tap_distance","_doubleTapThreshold","_tapThreshold","_tapDistanceThreshold","_longTapCancel","absolute","__boundToWorld","_lastUp","_lastDown","_lastMove","val","__getListenersByType","_assertThisInitialized","__key","__isDown","that","addEventListener","getAppearance","draw","getCenter","getRotation","getScale","app","__appearance","event","__formatTouchEvent","__lastDown","__fireEvent","isDown","found","__lastUp","lastDownDiff","__lastMove","handlers","getType","group","push","shift","callback","touches","step","_event","prop","array","__formatListener","__on","__off","Joystick","joystick","getDrawOptions","operating","Entity","Particle","ParticleEmitter","EngineContainer","UtilitiesContainer","IOContainer","JoystickSprite","TwoCylinder","IO","Sprites","Josystick","Utilities","rotation_lag","appearance","setAppearance","_velocity","_rotationLag","_rotation","_collisionGroup","__collisionGroupListening","__visible","center_x","center_y","worldClock","other","collisionFunction","objectIsCollidable","groupIsCollidable","getCollisionGroup","getVelocity","rotateTowards","setSpeed","isVisible","vis","__world","getWorld","exit","w","id","__emitter","emitter","clock","removeParticle","__particles","__toRemove","__isEmitting","__particleKey","getParticles","forEach","__removeParticles","isEmitting","particle","particleType","newParticle","__canvas","_scale","_resolution","style","__followInstance","__ios","__toRemoveIOs","__ioKey","getContext","clearRect","time","setCenterWithinBounding","clearCanvas","getBackground","getInstances","inst","getParticleEmitters","part","__removeIOs","getIOs","io","instance","_fps","__instances","__particleEmitters","__views","__toRemoveParticleEmitters","__toRemoveInstances","__toRemoveViews","__collisionGroups","__background","__instanceKey","__viewKey","__emitterKey","__clock","__intervalId","setInterval","loop","__removeParticleEmitters","__removeViews","__removeInstances","_this3","__preStep","me","hasCollisionChecking","getCollidableGroups","myCollisionGroups","__postStep","clearInterval","__addToCollisionGroup","splice","_defaultRadius","__isHeld","__pullRatio","__operateFunction","_previousEvent","onDown","linkEvent","onUp","onMove","stick","webpackPolyfill","deprecate","paths","children"],"mappings":"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","file":"opaque.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"opaque\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"opaque\"] = factory();\n\telse\n\t\troot[\"opaque\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","const TC = require('../../TwoCylinder/dist/twocylinder')\r\n\r\nclass OpaqueGame extends TC.Engine.Game {\r\n    init(window) {\r\n        let canvas = window.document.getElementById('world')\r\n        let menuBackground = new TC.Engine.Background({\r\n            color: '#ff7777'\r\n        })\r\n\r\n        let world = new TC.Engine.World({\r\n            fps: 30,\r\n            width: 800,\r\n            height: 1300,\r\n            background: menuBackground\r\n        })\r\n\r\n        let view = new TC.Engine.View({\r\n            canvas: canvas,\r\n            resolution: 2,\r\n            bounding: world.getBounding()\r\n        })\r\n\r\n        world.addView(view)\r\n\r\n        this.setWorld(world)\r\n        this.start()\r\n    }\r\n}\r\n\r\nwindow.OpaqueGame = OpaqueGame","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"twocylinder\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"twocylinder\"] = factory();\n\telse\n\t\troot[\"twocylinder\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","const Vector = require('./vector')\r\n\r\nConstants = {\r\n    TAU : Math.PI * 2\r\n}\r\n\r\nFunctions = {\r\n    disjoinArray2FromArray1(array1, array2, onEachMatchCallback) {\r\n        if (!array2.length) {\r\n            return\r\n        }\r\n        let i\r\n        let j\r\n        for (i=0; i<array2.length; i++) {\r\n            for(j=0; j<array1.length; j++){\r\n                if(array1[j].__id === array2[i].__id){\r\n                    if (typeof onEachMatchCallback === 'function') {\r\n                        onEachMatchCallback(array1[j])\r\n                    }\r\n                    delete array1[j].__id\r\n                    array1.splice(j,1)\r\n                    break\r\n                }\r\n            }\r\n        }\r\n    },\r\n    clone (obj) {\r\n        // TODO: Could this be improved? Taken from  https://stackoverflow.com/questions/41474986/how-to-clone-a-javascript-es6-class-instance\r\n        return Object.assign( Object.create( Object.getPrototypeOf(obj)), obj)\r\n    }\r\n}\r\n\r\nGeometry = {\r\n    /***************************************************\r\n     * BOXES\r\n     ***************************************************/\r\n    boxCollidesBox (box1, box2){\r\n        // both box1 and box 2 must have { x, y, width, height } properties\r\n        // if any part of box1's X is within box2's\r\n        let xOverlap = (\r\n            (\r\n                ( box1.origin_x <= box2.origin_x )\r\n                &&\r\n                ( (box1.origin_x + box1.width) > box2.origin_x )\r\n            )\r\n            ||\r\n            (\r\n                ( box2.origin_x <= box1.origin_x )\r\n                &&\r\n                ( (box2.origin_x + box2.width) > box1.origin_x )\r\n            )\r\n        )\r\n        let yOverlap = (\r\n            (\r\n                ( box1.origin_y <= box2.origin_y )\r\n                &&\r\n                ( (box1.origin_y + box1.height) > box2.origin_y )\r\n            )\r\n            ||\r\n            (\r\n                ( box2.origin_y <= box1.origin_y )\r\n                &&\r\n                ( (box2.origin_y + box2.height) > box1.origin_y )\r\n            )\r\n        )\r\n\r\n        return xOverlap && yOverlap\r\n    }\r\n    ,boxCollidesCircle (box, circle) {\r\n        let point1 = {x:box.origin_x, y:box.origin_y}\r\n        let point2 = {x:box.origin_x + box.width, y:box.origin_y}\r\n        let point3 = {x:box.origin_x + box.width, y:box.origin_y + box.height}\r\n        let point4 = {x:box.origin_x, y:box.origin_y + box.height}\r\n\r\n        let line1 = [point1,point2]\r\n        let line2 = [point2,point3]\r\n        let line3 = [point3,point4]\r\n        let line4 = [point4,point1]\r\n\r\n        return Geometry.pointCollidesBox(circle, box)\r\n            || Geometry.lineCollidesCircle(line1, circle, true)\r\n            || Geometry.lineCollidesCircle(line2, circle, true)\r\n            || Geometry.lineCollidesCircle(line3, circle, true)\r\n            || Geometry.lineCollidesCircle(line4, circle, true)\r\n    }\r\n    ,boxCollidesPoint (box, point){\r\n        return (\r\n            (\r\n                ( point.x >= box.origin_x )\r\n                &&\r\n                ( (box.origin_x + box.width) >= point.x )\r\n            )\r\n            &&\r\n            (\r\n                ( point.y >= box.origin_y )\r\n                &&\r\n                ( (box.origin_y + box.height) >= point.y )\r\n            )\r\n        )\r\n    }\r\n\r\n    /***************************************************\r\n     * CIRCLES\r\n     ***************************************************/\r\n    ,circleCollidesCircle (circle1, circle2){\r\n        return this.distanceToPoint(circle1,circle2) < (circle1.radius + circle2.radius)\r\n    }\r\n    ,circleCollidesBox (circle, box){\r\n        return Geometry.boxCollidesCircle(box,circle)\r\n    }\r\n    ,circleCollidesLine (circle,line, isSegment){\r\n        return Geometry.lineCollidesCircle(line,cricle,isSegment)\r\n    }\r\n    ,circleCollidesPoint (circle, point){\r\n        return Geometry.pointCollidesCircle(point, circle)\r\n    }\r\n\r\n\r\n    /***************************************************\r\n     * LINES\r\n     ***************************************************/\r\n    // This function returns an array of up to length 2 with points indicating at what points\r\n    // the given circle is intersected by the given line\r\n    ,lineIntersectsCircle (line, circle, isSegment){\r\n        let b = line[0]\r\n        let a = line[1]\r\n\r\n        // Calculate the euclidean distance between a & b\r\n        let eDistAtoB = Math.sqrt( Math.pow(b.x-a.x, 2) + Math.pow(b.y-a.y, 2) )\r\n\r\n        // compute the direction vector d from a to b\r\n        let d = { x : (b.x-a.x)/eDistAtoB, y : (b.y-a.y)/eDistAtoB }\r\n\r\n        // Now the line equation is x = dx*t + ax, y = dy*t + ay with 0 <= t <= 1.\r\n\r\n        // compute the value t of the closest point to the circle center (cx, cy)\r\n        let t = (d.x * (circle.x-a.x)) + (d.y * (circle.y-a.y))\r\n\r\n        // compute the coordinates of the point e on line and closest to c\r\n        let e = {\r\n            x : (t * d.x) + a.x,\r\n            y : (t * d.y) + a.y\r\n        }\r\n\r\n        // Calculate the euclidean distance between circle & e\r\n        let eDistCtoE = Math.sqrt( Math.pow(e.x-circle.x, 2) + Math.pow(e.y-circle.y, 2) )\r\n\r\n        let retVal = []\r\n\r\n        // test if the line intersects the circle\r\n        if( eDistCtoE < circle.radius ) {\r\n            // compute distance from t to circle intersection point\r\n            let dt = Math.sqrt( Math.pow(circle.radius, 2) - Math.pow(eDistCtoE, 2))\r\n\r\n            // compute first intersection point\r\n            let f = {\r\n                x : ((t-dt) * d.x) + a.x,\r\n                y : ((t-dt) * d.y) + a.y\r\n            }\r\n\r\n            if(!isSegment || Geometry.lineCollidesPoint(line, f, true)){\r\n                retVal.push(f)\r\n            }\r\n\r\n            // compute second intersection point\r\n            let g = {\r\n                x : ((t+dt) * d.x) + a.x,\r\n                y : ((t+dt) * d.y) + a.y\r\n            }\r\n\r\n            if(!isSegment || Geometry.lineCollidesPoint(line, g, true)){\r\n                retVal.push(g)\r\n            }\r\n        } else if (parseInt(eDistCtoE) === parseInt(circle.radius)) {\r\n            if(!isSegment || Geometry.lineCollidesPoint(line, e, true)){\r\n                retVal.push(e)\r\n            }\r\n        } else {\r\n            // do nothing, no intersection\r\n        }\r\n\r\n        return retVal\r\n    }\r\n\r\n    // true IFF a line passes through or tangent to a given circle\r\n    ,lineCollidesCircle (line, circle, isSegment){\r\n        let intersects = Geometry.lineIntersectsCircle(line, circle, isSegment)\r\n        return intersects.length > 0 || Geometry.pointCollidesCircle(line[0],circle)\r\n    }\r\n\r\n    ,lineCollidesPoint (line, point, isSegment){\r\n        let angleToPoint1 = Geometry.angleToPoint(line[0],point)\r\n        let angleToPoint2 = Geometry.angleToPoint(line[1],point)\r\n\r\n        let retVal = angleToPoint1 === angleToPoint2\r\n\r\n        // if the angle is off, we swap the order of two of the points for one of the measurements\r\n        // this simulates the 180 degree check\r\n        if(!retVal){\r\n            angleToPoint2 = Geometry.angleToPoint(point, line[1])\r\n            retVal = angleToPoint1 === angleToPoint2\r\n        }\r\n\r\n        if(retVal && isSegment){\r\n            retVal = Geometry.distanceToPoint(line[0],point) + Geometry.distanceToPoint(line[1],point)\r\n                === Geometry.distanceToPoint(line[0],line[1])\r\n        }\r\n\r\n        return retVal\r\n    }\r\n\r\n\r\n    /***************************************************\r\n     * POINTS\r\n     ***************************************************/\r\n    ,pointCollidesCircle (point, circle){\r\n        return Geometry.distanceToPoint(point,circle) <= circle.radius\r\n    }\r\n    ,pointCollidesBox (point, box){\r\n        return Geometry.boxCollidesPoint(box, point)\r\n    }\r\n    ,pointCollidesPoint (point1, point2){\r\n        return (\r\n            ( point1.x === point2.x )\r\n            &&\r\n            ( point1.y === point2.y )\r\n        )\r\n    }\r\n    ,pointCollidesLine (point, line){\r\n        return Geometry.lineCollidesPoint(line,point)\r\n    }\r\n\r\n    /***************************************************\r\n     * ANGLES AND DISTANCES\r\n     ***************************************************/\r\n    ,distanceToPoint (point1, point2){\r\n        let x = point1.x - point2.x\r\n        let y = point1.y - point2.y\r\n\r\n        return Math.sqrt( x*x + y*y )\r\n    }\r\n    ,angleToPoint (point1, point2, inDegrees){\r\n        let radians = Math.atan2(point2.y - point1.y, point2.x - point1.x)\r\n        return inDegrees ? ( radians * 180 / Math.PI ) : radians\r\n    }\r\n    /**\r\n     * @param {{x:*. y:*}} point1\r\n     * @param {{x:*. y:*}} point2\r\n     * @returns {Vector}\r\n     */\r\n    ,pointToPoint (point1, point2){\r\n        return new Vector({\r\n            speed : Geometry.distanceToPoint(point1,point2),\r\n            direction : Geometry.angleToPoint(point1,point2)\r\n        })\r\n    }\r\n    /**\r\n     * @param {{x:*,y:*}} point1\r\n     * @param {Vector} vector\r\n     * @returns {{x: *, y: *}}\r\n     */\r\n    ,pointFromVector (point1, vector){\r\n        return {\r\n            x : point1.x + Math.cos(vector.getDirection()) * vector.getSpeed(),\r\n            y : point1.y + Math.sin(vector.getDirection()) * vector.getSpeed()\r\n        }\r\n    }\r\n    ,getRandomDirection () {\r\n        return Math.random() * 2 * Math.PI\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    Geometry,\r\n    Functions,\r\n    Constants\r\n}","class Root {\r\n    constructor() {\r\n\r\n    }\r\n}\r\n\r\nmodule.exports = Root","const Root = require('./root')\r\nconst Bounding = require ('./bounding/bounding')\r\n\r\nclass Generic extends Root {\r\n\r\n    constructor (options) {\r\n        super (options)\r\n        this.setBounding(options.bounding)\r\n    }\r\n\r\n    collides (bounding) {\r\n        return this._bounding && this._bounding.collides(bounding)\r\n    }\r\n\r\n    getBounding () {\r\n        return this._bounding\r\n    }\r\n\r\n    setBounding (b) {\r\n        if(!b && ! (b instanceof Bounding)){\r\n            throw \"All objects must have a true bounding\"\r\n        }\r\n        return this._bounding = b\r\n    }\r\n}\r\n\r\nmodule.exports = Generic","/*\r\n    Profiles are used to remove the ambiguity with determining bounding box\r\n*/\r\n\r\nconst Root = require('../root')\r\n\r\nclass Bounding extends Root {\r\n    constructor (options){\r\n        super(options)\r\n        this.rotation = 0;\r\n        Object.entries(options).forEach((tuple) => {\r\n            this[tuple[0]] = tuple[1]\r\n        })\r\n    }\r\n    getCenter (){\r\n        return { x : null, y : null };\r\n    }\r\n    setCenter (tuple){\r\n        return null;\r\n    }\r\n    setCenterWithinContainer (tuple,bounding){\r\n        // if not implemented, just set the center normal style\r\n        return this.setCenter(tuple);\r\n    }\r\n    getContainingRectangle (){\r\n        return { origin_x : null, origin_y : null, width : null, height : null};\r\n    }\r\n    getRotation (){\r\n        return null;\r\n    }\r\n    setRotation (r){\r\n        this.rotation = r;\r\n    }\r\n    updateBounding (key, value){\r\n        if(typeof key === 'object'){\r\n            Object.entries(key).forEach((tuple) => {\r\n                this.updateBounding(...tuple)\r\n            })\r\n        }else{\r\n            this[key] = value\r\n        }\r\n        return this;\r\n    }\r\n    collides (bounding){\r\n        return false;\r\n    }\r\n}\r\n\r\nmodule.exports = Bounding","// CircleProfiles need a center point and a radius\r\n\r\nconst Bounding = require('./bounding')\r\nconst Geometry = require('../utilities').Geometry\r\nconst BoundingBox = require('./bounding_box')\r\nconst BoundingCircle = require('./bounding_circle')\r\n\r\nclass BoundingPoint extends Bounding {\r\n    getCenter (){\r\n        return { x : this.x, y : this.y };\r\n    }\r\n    setCenter (tuple){\r\n        this.x = tuple.x\r\n        this.y = tuple.y\r\n    }\r\n    getContainingRectangle (){\r\n        return{\r\n            origin_x : this.x\r\n            ,origin_y : this.y\r\n            ,width : 0\r\n            ,height : 0\r\n        }\r\n    }\r\n    collides (bounding){\r\n        if(bounding instanceof BoundingBox){\r\n            return Geometry.pointCollidesBox(this,bounding)\r\n        }else if(bounding instanceof BoundingCircle){\r\n            return Geometry.pointCollidesCircle(this,bounding)\r\n        }else if(bounding instanceof BoundingPoint){\r\n            return Geometry.pointCollidesPoint(this,bounding)\r\n        }else if(bounding instanceof Bounding){ \r\n            // if it's not a rectangle, circle, or point, it could be a new type of bounding\r\n            // in which case we let it handle the collision checking\r\n            return bounding.collides(this)\r\n        }else{ // treat bounding like a tuple\r\n            return Geometry.circleCollidesPoint(this, bounding)\r\n        }\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = BoundingPoint","// CircleProfiles need a center point and a radius\r\n\r\nconst Bounding = require('./bounding')\r\nconst Geometry = require('../utilities').Geometry\r\nconst BoundingBox = require('./bounding_box')\r\nconst BoundingPoint = require('./bounding_point')\r\n\r\nclass BoundingCircle extends Bounding {\r\n    getCenter (){\r\n        return { x : this.x, y : this.y };\r\n    }\r\n    setCenter (tuple){\r\n        this.x = tuple.x;\r\n        this.y = tuple.y;\r\n    }\r\n    getContainingRectangle (){\r\n        return{\r\n            origin_x : this.x - this.radius\r\n            ,origin_y : this.y - this.radius\r\n            ,width : 2 * this.radius\r\n            ,height : 2 * this.radius\r\n        }\r\n    }\r\n    collides (bounding){\r\n        if(bounding instanceof BoundingBox){\r\n            return Geometry.circleCollidesBox(this,bounding)\r\n        }else if(bounding instanceof BoundingCircle){\r\n            return Geometry.circleCollidesCircle(this,bounding);\r\n        }else if(bounding instanceof BoundingPoint){\r\n            return Geometry.circleCollidesPoint(this,bounding);\r\n        }else if(bounding instanceof Bounding){\r\n            // if it's not a rectangle, circle, or point, it could be a new type of bounding\r\n            // in which case we let it handle the collision checking\r\n            return bounding.collides(this);\r\n        }else{ // treat bounding like a tuple\r\n            return Geometry.circleCollidesPoint(this, bounding);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = BoundingCircle","// RectangleProfiles need an origin x,y and a width and height\r\nconst Bounding = require('./bounding')\r\nconst Geometry = require('../utilities').Geometry\r\nconst BoundingCircle = require('./bounding_circle')\r\nconst BoundingPoint = require('./bounding_point')\r\n\r\nclass BoundingBox extends Bounding {\r\n    getCenter (){\r\n        return {\r\n            x : this.origin_x + (this.width / 2)\r\n            , y : this.origin_y + (this.height / 2)\r\n        };\r\n    }\r\n    setCenter (tuple){\r\n        this.origin_x = tuple.x - (this.width / 2);\r\n        this.origin_y = tuple.y - (this.height / 2);\r\n    }\r\n    // TODO: This won't work properly with circles... Perhaps move it to the Geometry function and treat it like collisions\r\n    setCenterWithinBounding (tuple, bounding){\r\n        let containingBox = bounding.getContainingRectangle();\r\n        let myBox = this.getContainingRectangle();\r\n        \r\n        \r\n        let targetX = tuple.x;\r\n        let targetY = tuple.y;\r\n        \r\n        if(containingBox.width < myBox.width){\r\n            targetX = bounding.getCenter().x;\r\n        }else{\r\n            // to center within we take the min between x and the containingbox edge - 1/2 my width\r\n            targetX = Math.min(tuple.x, containingBox.origin_x + containingBox.width - (myBox.width/2) );\r\n            // then max it with the same on the other end\r\n            targetX = Math.max(targetX, containingBox.origin_x + (myBox.width/2));\r\n            // this ensures, when centered, our left and right edges do not cross the containingBox borders \r\n        }\r\n        \r\n        // Then, do it again for height\r\n        \r\n        if(containingBox.height < myBox.height){\r\n            targetY = bounding.getCenter().y;\r\n        }else{\r\n            // to center within we take the min between x and the containingbox edge - 1/2 my width\r\n            targetY = Math.min(tuple.y, containingBox.origin_y + containingBox.height - (myBox.height/2) );\r\n            // then max it with the same on the other end\r\n            targetY = Math.max(targetY, containingBox.origin_y + (myBox.height/2));\r\n            // this ensures, when centered, our left and right edges do not cross the containingBox borders\r\n        }\r\n        \r\n        this.setCenter({ x : targetX , y : targetY });\r\n    }\r\n\r\n    getContainingRectangle (){\r\n        return {\r\n            origin_x : this.origin_x\r\n            ,origin_y : this.origin_y\r\n            ,width : this.width\r\n            ,height : this.height\r\n        };\r\n    }\r\n\r\n    collides (bounding){\r\n        if(bounding instanceof BoundingBox){\r\n            return Geometry.boxCollidesBox(this,bounding)\r\n        }else if(bounding instanceof BoundingCircle){\r\n            return Geometry.boxCollidesCircle(this,bounding);\r\n        }else if(bounding instanceof BoundingPoint){\r\n            return Geometry.boxCollidesPoint(this,bounding);\r\n        }else if(bounding instanceof Bounding){\r\n            // if it's not a rectangle, circle, or point, it could be a new type of bounding\r\n            // in which case we let it handle the collision checking\r\n            return bounding.collides(this);\r\n        }else{ // treat bounding like a tuple\r\n            return Geometry.boxCollidesPoint(this, bounding);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = BoundingBox","/*\r\n This script defines the Vector object\r\n */\r\n\r\nconst Root = require('./root')\r\nconst Constants = require('./utilities').Constants\r\n\r\nclass Vector extends Root {\r\n    constructor (options) {\r\n        super (options)\r\n        options = Object.assign({\r\n            direction : 0,\r\n            speed : 0\r\n        },options)\r\n\r\n        this.__direction = options.direction\r\n        this.__speed = options.speed\r\n    }\r\n// ------------------------------------\r\n// GETTERS / SETTERS\r\n// ------------------------------------\r\n    getDirection (){\r\n        return this.__direction\r\n    }\r\n    getSpeed (){\r\n        return this.__speed\r\n    }\r\n    setDirection (dir){\r\n        this.__direction = dir\r\n    }\r\n    setSpeed  (speed) {\r\n        this.__speed = speed\r\n    }\r\n// ------------------------------------\r\n// CONVENIENCE FUNCTIONS\r\n// ------------------------------------\r\n    rotateTowards (dir, friction){\r\n        let currentDirection = this.getDirection()\r\n        let directionDiff = (dir + Constants.TAU - currentDirection) % Constants.TAU\r\n\r\n        friction = friction ? friction : 1\r\n        if (directionDiff <= (Math.PI) ){\r\n            this.setDirection(currentDirection + (directionDiff / friction))\r\n        }else{\r\n            this.setDirection(currentDirection - ( ( directionDiff - Math.PI ) / friction))\r\n        }\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = Vector","/*\r\n    This script defines an appearance.\r\n    Appearances are attached to instances and define how that instance should be drawn in the world\r\n*/\r\n\r\nconst Generic = require('./generic')\r\n\r\nclass Appearance extends Generic {\r\n    constructor (options) {\r\n        super(options)\r\n    }\r\n    \r\n    draw (canvas, x, y, rotation, scale, entity){\r\n        let context = canvas.getContext('2d');\r\n        context.beginPath();\r\n        context.arc(x, y, 20, 0, 2 * Math.PI, false);\r\n        context.fillStyle = 'grey';\r\n        context.fill();\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = '#333333';\r\n        context.stroke();\r\n    }\r\n}\r\n\r\nmodule.exports = Appearance","/*\r\n    Backgrounds are objects that control how the game background should appear. \r\n    At most, there should be one per world. \r\n*/\r\n\r\nconst Root = require('./root')\r\n\r\nclass Background extends Root {\r\n    constructor (options) {\r\n        super(options)\r\n        options = Object.assign({\r\n            color : 'transparent'\r\n        }, options)\r\n        this._color = options.color\r\n    }\r\n    draw (view){\r\n        let canvas = view.getCanvas()\r\n        let containingRectangle = view.getBounding().getContainingRectangle()\r\n        let context = canvas.getContext('2d')\r\n        context.beginPath()\r\n        context.fillStyle = this._color\r\n        context.fillRect(0,0,containingRectangle.width,containingRectangle.height)\r\n        context.fill()\r\n        context.stroke()\r\n    }\r\n}\r\n\r\nmodule.exports = Background","/*\r\n    This script creates a basic user interface\r\n*/\r\n\r\nconst BoundingPoint = require('../engine/bounding/bounding_point')\r\nconst Geometry = require('../engine/utilities').Geometry\r\n\r\nclass Event extends BoundingPoint {\r\n    static get EVENT_TYPES() {\r\n        return {\r\n            TAP : 'tap',\r\n            DOUBLE : 'doubletap',\r\n            LONG :'longtap',\r\n            MOVE : 'mousemove',\r\n            UP : 'mouseup',\r\n            DOWN : 'mousedown'\r\n        };\r\n    }\r\n\r\n    constructor (evt, view){\r\n        super (evt, view)\r\n        // -----------------------------------------------------\r\n        // This part was taken from Stack Overflow\r\n        // http://stackoverflow.com/questions/8389156\r\n        let el = evt.target,\r\n            x = 0,\r\n            y = 0\r\n\r\n        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {\r\n            x += el.offsetLeft - el.scrollLeft\r\n            y += el.offsetTop - el.scrollTop\r\n            el = el.offsetParent\r\n        }\r\n        // -----------------------------------------------------\r\n        \r\n        this._super('initialize',{\r\n            x : evt.clientX - x\r\n            ,y : evt.clientY - y\r\n        })\r\n        \r\n        if (view){\r\n            this.world_x = this.x + view.getBounding().origin_x\r\n            this.world_y = this.y + view.getBounding().origin_y\r\n            let rect = view.getCanvas().getBoundingClientRect()\r\n            this.device_x = this.x + rect.left\r\n            this.device_y = this.y + rect.top\r\n        }\r\n        \r\n        this.timestamp = Date.now()\r\n    }\r\n    linkEvent (evt){\r\n        // we want them to only link events\r\n        if(evt instanceof Event){\r\n            this.linked_event = evt; \r\n            this.velocity = Geometry.pointToPoint(this.linked_event, this)\r\n        }\r\n        \r\n        return this\r\n    }\r\n    setType (eventType){\r\n        if(Event.EVENT_TYPES.values().indexOf(eventType) === -1){\r\n            throw \"Invalid event type\"\r\n        }\r\n        this.type = eventType\r\n        return this\r\n    }\r\n    getType (){\r\n        return this.type ? this.type : null;\r\n    }\r\n}\r\n\r\n\r\nmodule.exports = Event","/*\r\n    This script creates a basic user interface\r\n*/\r\n\r\nconst Event = require('./event')\r\nconst Geometry = require('../engine/utilities').Geometry\r\nconst Generic = require('../engine/generic')\r\n\r\nclass Touch extends Generic {\r\n    constructor (options){\r\n        super(options)\r\n        this.__view = options.view\r\n        \r\n        //by default the touch location is the full canvas\r\n        options = Object.assign({\r\n            bounding : this.__view.getBounding()\r\n            ,double : 300\r\n            ,tap : 300\r\n            ,tap_distance : 20\r\n        }, options)\r\n        \r\n        this.setBounding(options.bounding)\r\n        \r\n        this._doubleTapThreshold = options.double\r\n        this._tapThreshold = options.tap\r\n        this._tapDistanceThreshold = options.tap_distance\r\n        this._longTapCancel = 2 * this._tapThreshold\r\n        \r\n        // absolute touch boxes are bound to the world which means the calculate touching\r\n        // via worldy coordinate systems as opposed to the view's relative coordinates [default]\r\n        if(options.absolute){\r\n            this.__boundToWorld = true\r\n        }\r\n        \r\n        // these events store the last events -- TODO : Maybe make them arrays? Store the trailing events?\r\n        this._lastUp = null\r\n        this._lastDown = null\r\n        this._lastMove = null\r\n        \r\n        // create a listener for each type of event\r\n        Event.EVENT_TYPES.forEach((val) => {\r\n            this.__getListenersByType.call(this,val)\r\n        })\r\n        \r\n        // id is set by the view when the touch object is inserted\r\n        this.__id = null\r\n\r\n        // key is used to track touch listeners\r\n        this.__key = 0\r\n        \r\n        // used to check if the touch is currently down\r\n        this.__isDown = false\r\n        \r\n        // What follows are the browser event binding calls\r\n        let that = this\r\n        this.__view.getCanvas().addEventListener('mousedown',function(evt){\r\n            that._handleDown.apply(that,arguments)\r\n        },false)\r\n        this.__view.getCanvas().addEventListener('touchstart',function(evt){\r\n            evt.preventDefault()\r\n            that._handleDown.apply(that,arguments)\r\n        },false)\r\n        \r\n        this.__view.getCanvas().addEventListener('mouseup',function(evt){\r\n            that._handleUp.apply(that,arguments)\r\n        },false)\r\n        this.__view.getCanvas().addEventListener('touchend',function(evt){\r\n            evt.preventDefault()\r\n            that._handleUp.apply(that,arguments)\r\n        },false)\r\n        \r\n        this.__view.getCanvas().addEventListener('mousemove',function(evt){\r\n            that._handleMove.apply(that,arguments)\r\n        },false)\r\n        this.__view.getCanvas().addEventListener('touchmove',function(evt){\r\n            evt.preventDefault()\r\n            that._handleMove.apply(that,arguments)\r\n        },false)\r\n    }\r\n    /*\r\n     * If this touch has an appearance, we draw it\r\n     */\r\n    draw (){\r\n        if(this.getAppearance()){\r\n            this.getAppearance().draw(\r\n                this.__view.getCanvas(), \r\n                this.getBounding().getCenter().x,\r\n                this.getBounding().getCenter().y, \r\n                this.__view.getRotation(),\r\n                this.__view.getScale(),\r\n                this\r\n            )\r\n        }\r\n    }\r\n    /*\r\n     * Appearance will be important for extended objects wishing to give the touch zones a visual represenation\r\n     */\r\n    setAppearance (app){\r\n        this.__appearance = app\r\n    }\r\n    \r\n    getAppearance (app){\r\n        return this.__appearance\r\n    }\r\n    \r\n    /*\r\n     * These function receive a browser event and determin whether or not\r\n     * to fire an IO event to listeners based on collision type, location, and touch state\r\n     * They are also responsible with properly formatting the IO event (determining if it's\r\n     * a single tap, double tap, move, etc...)\r\n     */\r\n    _handleDown (evt){\r\n        let event = this.__formatTouchEvent(evt)\r\n        if(!event){\r\n            return\r\n        }\r\n        event.setType(Event.EVENT_TYPES.DOWN)\r\n\r\n        this.__isDown = true\r\n        this.__lastDown = event\r\n        this.__fireEvent(event)\r\n    }\r\n    _handleUp (evt){\r\n        let event = this.__formatTouchEvent(evt)\r\n        if(!event){\r\n            return\r\n        }\r\n        \r\n        if(!this.isDown()){\r\n            return\r\n        }\r\n        \r\n        // found is used to determine if we've already assigned a type to this event before checking for others\r\n        // it's really just a helper variable so we can avoid deeply nested if / else ifs\r\n        let found = false\r\n        \r\n        // first we check for DOUBLE tap\r\n        if( this.__lastUp \r\n            && this.__lastUp.type == Event.EVENT_TYPES.TAP \r\n            && (this.__lastUp.timestamp - event.timestamp) <= this._doubleTapThreshold\r\n        ){\r\n            event.setType(Event.EVENT_TYPES.DOUBLE)\r\n            found = true\r\n        }\r\n        \r\n        // next we check for LONG tap\r\n        if(!found && this.__lastDown && (Geometry.distanceToPoint(this.__lastDown, event) < this._tapDistanceThreshold)){\r\n            let lastDownDiff = event.timestamp - this.__lastDown.timestamp\r\n            if(lastDownDiff <= this._tapThreshold){\r\n                event.setType(Event.EVENT_TYPES.TAP)\r\n                found = true\r\n            }else if(lastDownDiff <= this._longTapCancel){\r\n                event.setType(Event.EVENT_TYPES.LONG)\r\n                found = true\r\n            }else{\r\n                // do nothing, we're cancelling the long click\r\n            }\r\n        }\r\n        \r\n        // at this point, it must be the end of a move, so we give it a default\r\n        if(!found){\r\n            event.setType(Event.EVENT_TYPES.UP)\r\n        }\r\n        \r\n        event.linkEvent(this.__lastDown)\r\n        this.__lastUp = event\r\n        this.__fireEvent(event)\r\n        this.__isDown = false\r\n    }\r\n    _handleMove (evt){\r\n        if( !this.isDown()){\r\n            return\r\n        }\r\n        \r\n        let event = this.__formatTouchEvent(evt)\r\n        if(!event){\r\n            return\r\n        }\r\n        \r\n        if( \r\n            ( (event.timestamp - this.__lastDown.timestamp) <= this._longTapCancel)\r\n            &&\r\n            (Geometry.distanceToPoint(this.__lastDown, event) < this._tapDistanceThreshold)\r\n        ){\r\n            // if they haven't moved their finger enough and we're within the longtap threshold\r\n            return\r\n        }\r\n            \r\n        event.setType(Event.EVENT_TYPES.MOVE)\r\n        event.linkEvent(this.__lastMove)\r\n        this.__lastMove = event\r\n        this.__fireEvent(event)\r\n        \r\n    }\r\n    /*\r\n     * This function takes an IO Event and fires it to all bound listeners of its type\r\n     */\r\n    __fireEvent (event){\r\n        let handlers = this.__getListenersByType(event.getType())\r\n        if(handlers.length){\r\n            for(let i=0; i<handlers.length; i++){\r\n                handlers[i].callback(event)\r\n            }\r\n        }\r\n    }\r\n    /*\r\n     * This function will be used to queue previous events to  store a history rather than just\r\n     * the last one (lastMove, lastUp, lastDown)\r\n     */\r\n    __queueHistory (group,event){\r\n        group[0] = group[0].toUpperCase()\r\n        this['__last'+group].push(event)\r\n        this['__last'+group].shift()\r\n        return null\r\n    }\r\n    \r\n    /*\r\n     * This function might be uneeded? It basically adds all listeners to an array so we can\r\n     * potentially more easily track them (by key)\r\n     */\r\n    __formatListener (callback){\r\n        return {\r\n            key : ++this.__key\r\n            ,callback : callback\r\n        }\r\n    }\r\n    /*\r\n     * This function takes a browser event (mouse or touch) and converts it into a TwoCylinder IO event\r\n     * IFF it registered a collision with this touch space else it returns false \r\n     */ \r\n    __formatTouchEvent (evt){\r\n        //TODO: I'm not sure if this.collides will work for views that are not origin_x = 0, origin_y = 0\r\n        // BECAUSE, I think the event's x and y is relative to the device and the touch instance is relative\r\n        // to the world view (I THINK)\r\n        \r\n        // changed Touches is used for multitouch... ?\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/changedTouches\r\n        \r\n        let touches = evt.changedTouches ? evt.changedTouches : []\r\n\r\n        if(touches.length){\r\n            let event = false\r\n            let step = 0\r\n            \r\n            do{\r\n                if(step < touches.length){\r\n                    evt.clientX = touches[step].clientX\r\n                    evt.clientY = touches[step].clientY\r\n                }else{\r\n                    return false\r\n                }\r\n                event = new Event(evt,this.__view)\r\n                step++\r\n            }while(!this.collides(event))\r\n        }else{\r\n            event = new Event(evt,this.__view)\r\n            if(!this.collides(event)){\r\n                return false\r\n            }\r\n        }\r\n                \r\n        return event\r\n    }\r\n    /*\r\n     * WARNING: A bit of reflection here. Be careful...\r\n     * This function returns all bound listeners based on type\r\n     */\r\n    __getListenersByType (type){\r\n        if(!type){\r\n            return null\r\n        }\r\n        let prop = '__'+type+'Listeners'\r\n        if(!this[prop]){\r\n            this[prop] = []\r\n        }\r\n        return this[prop]\r\n    }\r\n    \r\n    /*\r\n     * This function is used to bind a handler to a certain type of IO event\r\n     */\r\n    __on (type,callback){\r\n        let array = this.__getListenersByType(type)\r\n        array.push(this.__formatListener(callback))\r\n    }\r\n    /*\r\n     * This function removes a passed binding\r\n     */\r\n    __off (type,callback){\r\n        let array = this.__getListenersByType(type)\r\n        for(let i=0; i<array.length; i++){\r\n            if(array[i].callback === callback){\r\n                delete array[i]\r\n            }\r\n        }\r\n    }\r\n    \r\n    /*\r\n     * The following are helper functions to make calling __on and __off more semantic\r\n     */\r\n    onDouble (callback){\r\n        this.__on(Event.EVENT_TYPES.DOUBLE,callback)\r\n    }\r\n    offDouble (callback){\r\n        this.__off(Event.EVENT_TYPES.DOUBLE,callback)\r\n    }\r\n    onLong (callback){\r\n        this.__on(Event.EVENT_TYPES.LONG,callback)\r\n    }\r\n    offLong (callback){\r\n        this.__off(Event.EVENT_TYPES.LONG,callback)\r\n    }\r\n    \r\n    onTap (callback){\r\n        this.__on(Event.EVENT_TYPES.TAP,callback)\r\n    }\r\n    offTap (callback){\r\n        this.__off(Event.EVENT_TYPES.TAP,callback)\r\n    }\r\n    \r\n    onDown (callback){\r\n        this.__on(Event.EVENT_TYPES.DOWN,callback)\r\n    }\r\n    offDown (callback){\r\n        this.__off(Event.EVENT_TYPES.DOWN,callback)\r\n    }\r\n    \r\n    onMove (callback){\r\n        this.__on(Event.EVENT_TYPES.MOVE,callback)\r\n    }\r\n    offMove (callback){\r\n        this.__off(Event.EVENT_TYPES.MOVE,callback)\r\n    }\r\n    \r\n    onUp (callback){\r\n        this.__on(Event.EVENT_TYPES.UP,callback)\r\n    }\r\n    offUp (callback){\r\n        this.__off(Event.EVENT_TYPES.UP,callback)\r\n    }\r\n    \r\n    /*\r\n     * This function can determine if this touch instance is being actively engaged\r\n     */\r\n    isDown (){\r\n        return this.__isDown\r\n    }\r\n}\r\n\r\nmodule.exports = Touch\r\n","/*\r\n    This script handles drawing the joystick appearance\r\n*/\r\n\r\nconst Appearance = require('../engine/appearance')\r\nconst BoundingCircle = require('../engine/bounding/bounding_circle')\r\n\r\nclass Joystick extends Appearance {\r\n    constructor (){\r\n        let options = {\r\n            bounding : new BoundingCircle({\r\n                x : 0\r\n                ,y : 0\r\n                ,radius : 20\r\n            })\r\n        }\r\n        \r\n        super(options)\r\n    }\r\n    draw (canvas,x,y,rotation,scale,joystick){\r\n        let options = joystick.getDrawOptions()\r\n        let context = canvas.getContext('2d')\r\n        \r\n        // if the joystick is being operated, we draw the binding circle\r\n        if(options.operating){\r\n            context.beginPath()\r\n            context.arc(x, y, 160, 0, 2 * Math.PI, false)\r\n            context.fillStyle = 'rgba(0,255,0,0.1)'\r\n            context.fill()\r\n            context.lineWidth = 3\r\n            context.strokeStyle = 'rgba(0,255,0,0.3)'\r\n            context.stroke()\r\n        }\r\n        \r\n        context.beginPath()\r\n        context.arc(x, y, 20, 0, 2 * Math.PI, false)\r\n        context.fillStyle = '#000000'\r\n        context.fill()\r\n        context.lineWidth = 5\r\n        context.strokeStyle = '#303030'\r\n        context.stroke()\r\n        \r\n        context.beginPath()\r\n        context.lineWidth = 18\r\n        context.strokeStyle = '#333333'\r\n        context.lineCap = 'round'\r\n        context.moveTo(options.stick.x, options.stick.y)\r\n        context.lineTo(x, y)\r\n        context.stroke()\r\n        \r\n        context.beginPath()\r\n        context.arc(options.stick.x, options.stick.y, 18, 0, 2 * Math.PI, false)\r\n        context.fillStyle = '#dd2222'\r\n        context.fill()\r\n        context.lineWidth = 5\r\n        context.strokeStyle = '#aa1111'\r\n        context.stroke()\r\n        \r\n        context.beginPath()\r\n        context.arc(options.stick.x + 6, options.stick.y - 6, 4, 0, 2 * Math.PI, false)\r\n        context.fillStyle = '#ffcccc'\r\n        context.fill()\r\n    }\r\n}\r\n\r\nmodule.exports = Joystick","const Bounding = require('./engine/bounding/bounding')\r\nconst BoundingPoint = require('./engine/bounding/bounding_point')\r\nconst BoundingCircle = require('./engine/bounding/bounding_circle')\r\nconst BoundingBox = require('./engine/bounding/bounding_box')\r\n\r\nconst Appearance = require('./engine/appearance')\r\nconst Background = require('./engine/background')\r\nconst Entity = require('./engine/entity')\r\nconst Game = require('./engine/game')\r\nconst Generic = require('./engine/generic')\r\nconst Particle = require('./engine/particle')\r\nconst ParticleEmitter = require('./engine/particle_emitter')\r\nconst Root = require('./engine/root')\r\nconst Vector = require('./engine/vector')\r\nconst View = require('./engine/view')\r\nconst World = require('./engine/world')\r\n\r\nlet EngineContainer = {\r\n    Bounding,\r\n    BoundingBox,\r\n    BoundingCircle,\r\n    BoundingPoint,\r\n    Appearance,\r\n    Background,\r\n    Entity,\r\n    Game,\r\n    Generic,\r\n    ParticleEmitter,\r\n    Particle,\r\n    Root,\r\n    World,\r\n    View,\r\n    Vector\r\n}\r\n\r\nconst {\r\n    Functions,\r\n    Geometry,\r\n    Constants\r\n} = require('./engine/utilities')\r\n\r\nlet UtilitiesContainer = {\r\n    Functions,\r\n    Constants,\r\n    Geometry,\r\n}\r\n\r\nconst Event = require('./io/event')\r\nconst Touch = require('./io/touch')\r\nconst Joystick = require('./io/joystick')\r\n\r\nlet IOContainer = {\r\n    Event,\r\n    Touch,\r\n    Joystick\r\n}\r\n\r\n\r\nconst JoystickSprite = require('./sprites/joystick')\r\nlet SpritesContainer = {\r\n    Josystick: JoystickSprite\r\n}\r\n\r\nTwoCylinder = {\r\n    Engine: EngineContainer,\r\n    IO: IOContainer,\r\n    Sprites: SpritesContainer,\r\n    Utilities: UtilitiesContainer\r\n};\r\n\r\nmodule.exports = TwoCylinder","const Generic = require('./generic')\r\nconst Appearance = require('./appearance')\r\nconst Vector = require('./vector')\r\nconst BoundingPoint = require('./bounding/bounding_point')\r\n\r\nclass Entity extends Generic {\r\n    constructor (options){\r\n        super(options)\r\n\r\n        // -------------------------------\r\n        this.__appearance = null\r\n\r\n        options = Object.assign({\r\n            velocity : null // Vector :: the instance's velocity vector\r\n            ,rotation : 0 // float :: the instance's this.__appearance rotation\r\n            ,rotation_lag : 20 // int :: the number of steps it will take to turnTowards a target direction\r\n        }, options)\r\n\r\n        if(options.appearance){\r\n            this.setAppearance(options.appearance)\r\n        }\r\n\r\n        this._velocity = options.velocity\r\n        this._rotationLag = options.rotation_lag\r\n        this._rotation = options.rotation\r\n        this._collisionGroup = 'ENTITY'\r\n\r\n        // -------------------------------\r\n\r\n        // id is set by the world when it's inserted\r\n        this.__id = null\r\n        this.__collisionGroupListening = {}\r\n\r\n        this.__visible = true;           // boolean  :: is this instance visible\r\n    }\r\n\r\n    // draw is called by a view.\r\n    // the view passes a callback function which is called IFF this instance is to be drawn\r\n    // passed to that function is important information that will be forwarded to the Instance's this.__appearance\r\n    draw (view, center_x, center_y) {\r\n        this.getAppearance().draw(\r\n            view.getCanvas(),\r\n            center_x,\r\n            center_y,\r\n            view.getRotation() * this._rotation, // TODO: this is probably wrong? haven't tested\r\n            view.getScale(),\r\n            this\r\n        )\r\n    }\r\n    preStep (worldClock){\r\n        return\r\n    }\r\n    step (worldClock){\r\n        if(this.getSpeed()){\r\n            this.getBounding().setCenter({\r\n                x : this.getBounding().getCenter().x + this.getSpeed() * Math.cos(this.getDirection())\r\n                ,y : this.getBounding().getCenter().y + this.getSpeed() * Math.sin(this.getDirection())\r\n            })\r\n\r\n            if(this.getAppearance()){\r\n                this.getAppearance().getBounding().setCenter(this.getBounding().getCenter())\r\n            }\r\n        }\r\n    }\r\n    postStep (worldClock){\r\n        return\r\n    }\r\n    /****************************************************************************\r\n     COLLISIONS AND COLLISION CHECKING\r\n     ****************************************************************************/\r\n\r\n    // this will return what collision group this entity belongs to\r\n    getCollisionGroup (){\r\n        return this._collisionGroup\r\n    }\r\n\r\n    getCollidableGroups (){\r\n        return Object.keys(this.__collisionGroupListening)\r\n    }\r\n\r\n    // this function passes an other instance and signifies a collision has occurred\r\n    // this instance then determines if it should react to the collision or not\r\n    handleCollidedWith (other){\r\n        let collisionFunction = this.objectIsCollidable(other)\r\n        if(collisionFunction){\r\n            collisionFunction.apply(this,[other])\r\n        }\r\n    }\r\n\r\n    groupIsCollidable (group){\r\n        let retVal = false\r\n        if(this.__collisionGroupListening[other]){\r\n            retVal = this.__collisionGroupListening[other]\r\n        }\r\n        return retVal\r\n    }\r\n\r\n    // this function will return the collision function for a passed Entity instance\r\n    // or false IFF there is no corresponding collision function\r\n    objectIsCollidable (other){\r\n        let retVal = false\r\n\r\n        if (other instanceof Entity) {\r\n            return this.groupIsCollidable(other.getCollisionGroup())\r\n        }\r\n\r\n        return retVal\r\n    }\r\n\r\n    // this will return true IFF this object is listening for collisions\r\n    hasCollisionChecking (){\r\n        return this.__collisionGroupListening.hasOwnProperty\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    // this collision function handles collisions between this instance and instances of a specified Group\r\n    onCollideGroup (group, callback){\r\n        this.__collisionGroupListening[group] = callback\r\n    }\r\n\r\n    offCollideGroup (group){\r\n        delete this.__collisionGroupListening[group]\r\n    }\r\n\r\n    /****************************************************************************\r\n     GETERS AND SETTERS\r\n     ****************************************************************************/\r\n\r\n    getPosition (){\r\n        return this.getBounding().getCenter()\r\n    }\r\n\r\n    /**\r\n     * tuple can either be a boundingPoint, tuple (x & y) or just x (in which case y is y)\r\n     */\r\n    setPosition (tuple, y){\r\n        if(tuple instanceof BoundingPoint){\r\n            this.getBounding().updateBounding(tuple.getCenter())\r\n        }else if(typeof tuple === 'object'){\r\n            this.getBounding().updateBounding({x:tuple.x,y:tuple.y})\r\n        }else{\r\n            this.getBounding().updateBounding(tuple,y)\r\n        }\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    /**\r\n     * app is an Appearance object\r\n     * when setting an this.__appearance object, you can also change the collision box by passing new collision dimensions\r\n     * \"box\" can either be a tuple (width & height) or just width in which case h is height\r\n     */\r\n    setAppearance (app){\r\n        if (!(app instanceof Appearance)) {\r\n            throw \"Appearance must be a instance of Appearance\"\r\n        }\r\n        this.__appearance = app\r\n    }\r\n\r\n    // This function defines how to draw this instance\r\n    getAppearance (){\r\n        return this.__appearance\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    getDirection (){\r\n        return this.getVelocity().getDirection()\r\n    }\r\n    rotateTowards (dir){\r\n        this.getVelocity().rotateTowards(dir, this._rotationLag)\r\n    }\r\n    setDirection (dir){\r\n        this.getVelocity().setDirection(dir)\r\n\r\n        return this.getDirection()\r\n    }\r\n\r\n    getSpeed (){\r\n        return this.getVelocity().getSpeed()\r\n    }\r\n\r\n    setSpeed (speed){\r\n        this.getVelocity().setSpeed(speed)\r\n    }\r\n\r\n    setVelocity (velocity) {\r\n        this._velocity = velocity\r\n    }\r\n    getVelocity () {\r\n        if (!this._velocity) {\r\n            this._velocity = new Vector()\r\n        }\r\n        return this._velocity\r\n    }\r\n\r\n    // ----------------------\r\n\r\n    getVisible (){\r\n        return this.isVisible()\r\n    }\r\n\r\n    isVisible (){\r\n        // must be in the world, visible, and with an appearance\r\n        return this.__id && this.__visible && !!this.__appearance\r\n    }\r\n\r\n    setVisible (vis){\r\n        this.__visible =  vis\r\n    }\r\n}\r\n\r\nmodule.exports = Entity","const Root = require('./root')\r\n\r\nclass Game extends Root {\r\n    constructor () {\r\n        super()\r\n        this.__world = undefined;\r\n    }\r\n\r\n    start (){\r\n        return this.getWorld().start();\r\n    }\r\n\r\n    exit (){\r\n        return this.getWorld().exit();\r\n    }\r\n\r\n    setWorld (w){\r\n        this.__world = w;\r\n    }\r\n\r\n    getWorld (){\r\n        return this.__world;\r\n    }\r\n}\r\n\r\nmodule.exports = Game","/*\r\n This script defines the particle object\r\n */\r\nconst Root = require('./root')\r\n\r\n\r\nclass Particle extends Root {\r\n    constructor(options) {\r\n        super(options)\r\n        options = Object.assign({}, options)\r\n        this.__id = options.id\r\n        this.__emitter = options.emitter\r\n    }\r\n    // This function is responsible for moving the particle or otherwise tracking its lifecycle\r\n    step (clock) {\r\n        return null\r\n    }\r\n    draw (canvas,x,y,rotation,scale,emitter){\r\n        let context = canvas.getContext('2d')\r\n        context.beginPath()\r\n        context.arc(x, y, 20, 0, 2 * Math.PI, false)\r\n        context.fillStyle = 'grey'\r\n        context.fill()\r\n        context.lineWidth = 5\r\n        context.strokeStyle = '#333333'\r\n        context.stroke()\r\n    }\r\n    destroy () {\r\n        this.__emitter.removeParticle(this)\r\n    }\r\n}\r\n\r\nmodule.exports = Particle\r\n","const Functions = require('./utilities').Functions\r\nconst Generic = require('./generic')\r\n\r\nclass ParticleEmitter extends Generic {\r\n    constructor(options) {\r\n        super(options)\r\n\r\n        // -------------------------------\r\n        this.__particles = []\r\n        this.__toRemove = []\r\n\r\n        // by default, newly created emitters do not emit until told to\r\n        this.__isEmitting = false\r\n\r\n        // an internal id counter\r\n        this.__particleKey = 0\r\n\r\n        // id is set by the world when it's inserted\r\n        this.__id = null\r\n    }\r\n    // an emitter drawing basically just calls draw on all its particles\r\n    // particles are like appearances, but without bounding boxes - they just get drawn if the emitter is in\r\n    // collision with the view\r\n    draw (view, center_x, center_y){\r\n        this.getParticles().forEach((p) => {\r\n            p.draw(view.getCanvas(),\r\n                center_x,\r\n                center_y,\r\n                view.getRotation() * this._rotation,\r\n                view.getScale(),\r\n                this)\r\n        })\r\n    }\r\n    step (clock) {\r\n        this.getParticles().forEach((p) => {\r\n            p.step(clock)\r\n        })\r\n\r\n        this.__removeParticles()\r\n    }\r\n    destroy () {\r\n        this.__particles = []\r\n    }\r\n    setIsEmitting(isEmitting) {\r\n        this.__isEmitting = isEmitting\r\n    }\r\n    getIsEmitting() {\r\n        return this.__isEmitting\r\n    }\r\n\r\n    /****************************************************************************\r\n     PARTICLES\r\n     ****************************************************************************/\r\n    getParticles () {\r\n        return this.__particles\r\n    }\r\n    removeParticle (particle) {\r\n        this.__toRemove.push(particle)\r\n    }\r\n\r\n    __removeParticles (particle) {\r\n        Functions.disjoinArray2FromArray1(this.__particles, this.__toRemove)\r\n        this.__toRemove = []\r\n    }\r\n    /**\r\n     * It may be advantageous for particle emitters to emit particles one at a time\r\n     * rather than repeatedly. In that case, this function can be used\r\n     * @param {function} particleType\r\n     * @param {object} options\r\n     */\r\n    emitParticle(particleType, options) {\r\n        let newParticle\r\n\r\n        options = Object.assign({\r\n            id : ++this.__particleKey,\r\n            emitter : this\r\n        }, options)\r\n        newParticle = new particleType(options)\r\n        this.__particles.push(newParticle)\r\n\r\n        return newParticle\r\n    }\r\n}\r\n\r\nmodule.exports = ParticleEmitter","/*\r\n    This script defines a this.__world's view.\r\n    Views are attached to this.__worlds and help determine which instances should be drawn to the this.__canvas and where\r\n*/\r\n\r\nconst Generic = require('./generic')\r\nconst Functions = require('./utilities').Functions\r\n\r\nclass View extends Generic {\r\n    constructor (options){\r\n        super(options)\r\n        this.__canvas = options.canvas\r\n        \r\n        this._rotation = options.rotation || 0\r\n        this._scale = options.scale || 1\r\n        this._resolution = options.resolution || 1\r\n        \r\n        this.__canvas.width = this.getBounding().width * this._resolution\r\n        this.__canvas.height = this.getBounding().height * this._resolution\r\n        this.__canvas.style.width = this.getBounding().width + \"px\"\r\n        this.__canvas.style.height = this.getBounding().height + \"px\"\r\n        \r\n        this.__followInstance = false\r\n        \r\n        this.__ios = []\r\n        this.__toRemoveIOs = []\r\n        this.__ioKey = 0\r\n\r\n        // id is set by the world when it's inserted\r\n        this.__id = null\r\n    }\r\n    clearCanvas (){\r\n        this.__canvas.getContext('2d').clearRect(0,0,this.__canvas.width,this.__canvas.height)\r\n    }\r\n    draw (time){\r\n        let i\r\n        let instances\r\n        let particles\r\n        let ios\r\n        let that = this\r\n\r\n        // before we draw, we want to re-center on our tracked instance if we have one\r\n        if(this.__followInstance){\r\n            this.getBounding().setCenterWithinBounding(\r\n                this.__followInstance.getBounding().getCenter()\r\n                , this.__world.getBounding()\r\n            )\r\n        }\r\n        \r\n        // prepare to draw\r\n        this.clearCanvas()\r\n        \r\n        // first draw the world's background\r\n        this.__world.getBackground().draw(this)\r\n        \r\n        // get all instances and loop through them\r\n        this.__world.getInstances().forEach((inst) => {\r\n            // skip invisible instances\r\n            if(!inst.isVisible()){\r\n                return\r\n            }\r\n            // if this instance's appearance is inside this view box\r\n            // NOTE: we check the appearance's bounding because it may be desirable for the calculated collision box\r\n            // to be different from what is considered visible. for example, if the appearance draws shadows\r\n            // those shadows might not be collidable with other entities, but should be included in\r\n            // determining whether or not to draw the entity to a view.\r\n            if( that.collides( inst.getAppearance().getBounding() ) ){\r\n                //then we draw the instance and pass the view so it can reference the view's\r\n                //transitions and transformation (rotation, scale, etc)\r\n                inst.draw(\r\n                    that\r\n                    ,inst.getBounding().getCenter().x - that.getBounding().getContainingRectangle().origin_x\r\n                    ,inst.getBounding().getCenter().y - that.getBounding().getContainingRectangle().origin_y\r\n                )\r\n            }\r\n        })\r\n\r\n        // Draw each particle emitter\r\n        this.__world.getParticleEmitters().forEach((part) => {\r\n            if (that.collides(part.getBounding())) {\r\n                part.draw(\r\n                    that,\r\n                    part.getBounding().getCenter().x - that.getBounding().getContainingRectangle().origin_x,\r\n                    part.getBounding().getCenter().y - that.getBounding().getContainingRectangle().origin_y\r\n                )\r\n            }\r\n        })\r\n\r\n        // check if any IOs have been removed\r\n        this.__removeIOs()\r\n\r\n        //now we loop through the IO handlers for this view\r\n        this.getIOs().forEach((io) => {\r\n            io.draw()\r\n        })\r\n    }\r\n/****************************************************************************\r\nGETTER AND SETTER FUNCTIONS\r\n****************************************************************************/\r\n    getCanvas (){\r\n        return this.__canvas\r\n    }\r\n    getWorld (){\r\n        return this.__world\r\n    }\r\n    setWorld (world){\r\n        this.__world = world\r\n    }\r\n    getRotation (){\r\n        return this._rotation\r\n    }\r\n    setRotation (r){\r\n        this._rotation = r\r\n    }\r\n    getScale (){\r\n        return this._scale\r\n    }\r\n    setScale (s){\r\n        this._scale = s\r\n    }\r\n/****************************************************************************\r\nIO FUNCTIONS\r\n****************************************************************************/    \r\n    removeIO (io){\r\n        if(io.__id){\r\n            this.__toRemoveIOs.push(io)\r\n        }\r\n        \r\n        return io\r\n    }\r\n    __removeIOs () {\r\n        Functions.disjoinArray2FromArray1(this.__ios, this.__toRemoveIOs)\r\n\r\n        this.__toRemoveIOs = []\r\n    }\r\n    addIO(io){\r\n        if(io.__id){\r\n            throw \"IO already added\"\r\n        }\r\n        io.__id = ++this.__ioKey\r\n\r\n        this.__ios.push(io)\r\n       \r\n        return io\r\n    }\r\n   \r\n    getIOs() {\r\n        return this.__ios\r\n    }\r\n    \r\n    // this gets the mouse position by world, view, and device OR any one of them as an x,y tuple\r\n    getMousePosition (evt) {\r\n        return new TwoCylinder.IO.Event(evt, this)\r\n    }\r\n    \r\n    followInstance (instance){\r\n        if(instance){\r\n            this.__followInstance = instance\r\n        } else {\r\n            this.__followInstance = false\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = View","const Generic = require('./generic')\r\nconst Background = require('./background')\r\nconst BoundingBox = require('./bounding/bounding_box')\r\nconst Functions = require('./utilities').Functions\r\n\r\nclass World extends Generic {\r\n    constructor (options) {\r\n        options.bounding = new BoundingBox({\r\n            origin_x : 0\r\n            ,origin_y : 0\r\n            ,width : options.width\r\n            ,height : options.height\r\n        })\r\n        super(options)\r\n        this._fps = options.fps || 30\r\n\r\n        this.__instances = []\r\n        this.__particleEmitters = []\r\n        this.__views = []\r\n\r\n        this.__toRemoveParticleEmitters = []\r\n        this.__toRemoveInstances = []\r\n        this.__toRemoveViews = []\r\n\r\n        this.__collisionGroups = {}\r\n        this.__background = options.background || new Background()\r\n\r\n        this.__instanceKey = 0\r\n        this.__viewKey = 0\r\n        this.__emitterKey = 0\r\n        this.__clock = 0\r\n    }\r\n\r\n    //TODO: Needs to somehow sync touch events up with the game clock\r\n    start (){\r\n        this.__intervalId = setInterval(() => {\r\n            try{\r\n                this.loop.apply(this, [])\r\n            } catch (e) {\r\n                this.exit(e)\r\n            }\r\n        }, 1000 / this._fps)\r\n    }\r\n\r\n    __preStep (time){\r\n        // we have each instance perform a frame step.\r\n        this.__instances.forEach((inst) => {\r\n            inst.preStep(time)\r\n        })\r\n    }\r\n\r\n    __postStep (time){\r\n        // we have each instance perform a frame step.\r\n        this.__instances.forEach((inst) => {\r\n            inst.postStep(time)\r\n        })\r\n\r\n        this.__removeParticleEmitters()\r\n        this.__removeViews()\r\n        this.__removeInstances()\r\n    }\r\n\r\n    loop (){\r\n        this.__preStep(++this.__clock)\r\n\r\n        // we have each instance perform a frame step.\r\n        this.__particleEmitters.forEach((part) => {\r\n            part.step(this.__clock)\r\n        })\r\n\r\n        // we have each instance perform a frame step.\r\n        this.__instances.forEach((inst) => {\r\n            inst.step(this.__clock)\r\n        })\r\n\r\n        // check for collisions\r\n        this.__instances.forEach((me) => {\r\n            if (me.hasCollisionChecking()) {\r\n                let myCollisionGroups = me.getCollidableGroups()\r\n                myCollisionGroups.forEach((group) => {\r\n                    // if there are instances that match the groups im listening for\r\n                    if (this.__collisionGroups[group] && this.__collisionGroups[group].length) {\r\n\r\n                        // for each of those matching instance types,\r\n                        this.__collisionGroups[group].forEach( (other) => {\r\n\r\n                            // if they're not me, and I collide with them\r\n                            if (me.__id !== other.__id && me.collides(other.getBounding())) {\r\n                                me.handleCollidedWith(other)\r\n                            }\r\n                        })\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n        // draw the views\r\n        this.__views.forEach((view) => {\r\n            view.draw(this.__clock)\r\n        })\r\n\r\n        this.__postStep(this.__clock)\r\n    }\r\n\r\n    exit (){\r\n        clearInterval(this.__intervalId)\r\n\r\n        //TODO: handle exit\r\n    }\r\n\r\n    /****************************************************************************\r\n     INSTANCE FUNCTIONS\r\n     ****************************************************************************/\r\n    removeInstance (instance){\r\n        if(instance.__id){\r\n            // we add their id to the array of instances to remove\r\n            this.__toRemoveInstances.push(instance)\r\n        }\r\n        return instance\r\n    }\r\n    __removeInstances () {\r\n        disjoinArray2FromArray1(this.__instances, this.__toRemoveInstances, this.__removeFromCollisionGroup)\r\n        this.__toRemoveInstances = []\r\n    }\r\n\r\n    addInstance (instance){\r\n        if(instance.__id){\r\n            throw \"Instance already added\"\r\n        }\r\n        instance.__id = ++this.__instanceKey\r\n        // add it to the big list\r\n        this.__instances.push(instance)\r\n        // also add it according to its collision group\r\n        this.__addToCollisionGroup(instance)\r\n\r\n        return instance\r\n    }\r\n\r\n    getInstances (){\r\n        return this.__instances\r\n    }\r\n\r\n    /****************************************************************************\r\n     VIEW FUNCTIONS\r\n     ****************************************************************************/\r\n    addView (view){\r\n        if (view.__id) {\r\n            throw \"View already added\"\r\n        }\r\n        view.__id = ++this.__viewKey\r\n        view.setWorld(this)\r\n        this.__views.push(view)\r\n\r\n        return view\r\n    }\r\n\r\n    getViews (){\r\n        return this.__views\r\n    }\r\n\r\n    __removeViews () {\r\n        disjoinArray2FromArray1(this.__views, this.__toRemoveViews)\r\n\r\n        this.__toRemoveViews = []\r\n    }\r\n\r\n    removeView (view){\r\n        if(view.__id) {\r\n            // we add them to the array of views to remove\r\n            this.__toRemoveViews.push(view)\r\n        }\r\n        return view\r\n    }\r\n\r\n    /****************************************************************************\r\n     PARTICLE FUNCTIONS\r\n     ****************************************************************************/\r\n    addParticleEmitter (emitter){\r\n        if (emitter.__id){\r\n            throw \"Emitter already added\"\r\n        }\r\n        emitter.__id = ++this.__emitterKey\r\n        this.__particleEmitters.push(emitter)\r\n        return emitter\r\n    }\r\n\r\n    removeParticleEmitter (emitter){\r\n        if (emitter.__id) {\r\n            // we add their id to the array of emitters to remove\r\n            this.__toRemoveParticleEmitters.push(emitter)\r\n        }\r\n        return emitter\r\n    }\r\n    __removeParticleEmitters (){\r\n        disjoinArray2FromArray1(this.__particleEmitters, this.__toRemoveParticleEmitters)\r\n\r\n        this.__toRemoveParticleEmitters = []\r\n    }\r\n    getParticleEmitters () {\r\n        return this.__particleEmitters\r\n    }\r\n    /****************************************************************************\r\n     BACKGROUND FUNCTIONS\r\n     ****************************************************************************/\r\n    setBackground (background){\r\n        this.__background = background\r\n    }\r\n\r\n    getBackground (){\r\n        return this.__background\r\n    }\r\n    /****************************************************************************\r\n     HELPER FUNCTIONS\r\n     ****************************************************************************/\r\n    __addToCollisionGroup (instance){\r\n        let group = instance.getCollisionGroup()\r\n\r\n        if(!this.__collisionGroups[group]){\r\n            this.__collisionGroups[group] = []\r\n        }\r\n        this.__collisionGroups[group].push(instance)\r\n    }\r\n    __removeFromCollisionGroup (instance){\r\n        let i\r\n        let group = instance.getCollisionGroup()\r\n\r\n        if (!this.__collisionGroups[group]) {\r\n            throw \"Collision Group does not exist\"\r\n        }\r\n\r\n        for(i=0; i<this.__collisionGroups[group].length; i++){\r\n            if(this.__collisionGroups[group][i].__id === instance.__id){\r\n                this.__collisionGroups[group].splice(i,1)\r\n                break\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = World","/*\r\n    This script handles drawing the joystick appearance\r\n*/\r\n\r\nconst Touch = require('./touch')\r\nconst BoundingCircle = require('../engine/bounding/bounding_circle')\r\nconst {Geometry, Functions} = require('../engine/utilities')\r\nconst JoystickSprite = require('../sprites/joystick')\r\n\r\nclass Joystick extends Touch {\r\n    constructor (options){\r\n        let defaultRadius = 40\r\n        options.tap_distance = 0\r\n        options.bounding = new BoundingCircle({\r\n            x : options.x\r\n            ,y : options.y\r\n            ,radius : defaultRadius\r\n        })\r\n        super (options)\r\n        this._defaultRadius = defaultRadius\r\n\r\n        this.__isHeld = false\r\n        \r\n        this.__pullRatio = 1.8\r\n        \r\n        // the operate function is what we will pass joystick motions to\r\n        this.__operateFunction = null\r\n        \r\n        this.__appearance = new JoystickSprite()\r\n        \r\n        this._previousEvent = null\r\n        \r\n        this.onDown((evt) => {\r\n            this._previousEvent = evt; //initialize evt\r\n            \r\n            // we link to itself so that the joystick draws properly\r\n            this._previousEvent.linkEvent(evt)\r\n\r\n            this.getBounding().updateBounding({\r\n                radius : 4 * this._defaultRadius\r\n            })\r\n            \r\n            if(typeof this.__operateFunction === 'function'){\r\n                if (evt.velocity) {\r\n                    evt.velocity.setSpeed(0)\r\n                }\r\n                this.__operateFunction(evt)\r\n            }\r\n        })\r\n        \r\n        this.onUp((evt) => {\r\n            this.getBounding().updateBounding({\r\n                radius : this._defaultRadius\r\n            })\r\n            delete this._previousEvent\r\n            \r\n            if(typeof this.__operateFunction === 'function'){\r\n                if (evt.velocity) {\r\n                    evt.velocity.setSpeed(0)\r\n                }\r\n                this.__operateFunction(evt)\r\n            }\r\n        })\r\n        \r\n        this.onMove((evt) => {\r\n            if (this.isDown()){\r\n                evt.linkEvent(this.__lastDown)\r\n                if(typeof(this.__operateFunction) === 'function'){\r\n                    //want to make the max speed the distance we allow the joystick to move\r\n                    if (evt.velocity) {\r\n                        evt.velocity.setSpeed(Math.min(evt.velocity.getSpeed(), this._defaultRadius / this.__pullRatio))\r\n                    }\r\n                    this.__operateFunction(evt)\r\n                }\r\n                this._previousEvent = evt\r\n            }\r\n        })\r\n    }\r\n    onOperate (callback){\r\n        this.__operateFunction = callback\r\n    }\r\n    offOperate (){\r\n        delete this.__operateFunction; \r\n    }\r\n    getDrawOptions () {\r\n        let options = {\r\n            stick : this.getBounding().getCenter()\r\n            ,operating : this.isDown()\r\n        }\r\n        \r\n        if(this._previousEvent && this._previousEvent.velocity){\r\n            let vector = Functions.clone(this._previousEvent.velocity)\r\n            vector.setSpeed(Math.min(this._defaultRadius / this.__pullRatio, this._previousEvent.velocity.getSpeed()))\r\n            options.stick = Geometry.pointFromVector(options.stick, vector)\r\n        }\r\n        \r\n        return options\r\n    }\r\n}\r\n\r\nmodule.exports = Joystick","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n"],"sourceRoot":""}